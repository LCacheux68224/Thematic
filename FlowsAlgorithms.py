# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Thematic
                                 A QGIS plugin
 Thematic cartography tools for processing
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-19
        copyright            : (C) 2018 by Lionel Cacheux
        email                : lionel.cacheux@gmx.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lionel Cacheux'
__date__ = '2018-07-19'
__copyright__ = '(C) 2018 by Lionel Cacheux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication
from qgis.PyQt.QtCore import QVariant
import os, math
from PyQt5.QtGui import (QIcon, QColor)
from qgis.core import (QgsProcessing,
                       QgsProject,
                       QgsMessageLog,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterVectorLayer,
                       QgsCoordinateReferenceSystem,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsFeatureRequest,
                       QgsField,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterField,
                       QgsProcessingParameterDefinition,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsGeometry,
                       QgsDistanceArea,
                       QgsSimpleLineSymbolLayer,
                       QgsProcessingUtils,
                       QgsArrowSymbolLayer,
                       QgsSymbol,
                       QgsPoint,
                       QgsProcessingParameterBoolean,
                       QgsExpressionContextUtils,
                       QgsProcessingParameterString,
                       QgsProperty,
                       QgsWkbTypes)
import processing
from qgis.utils import iface

class CreateLinesAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'
    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        '''
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )
        '''
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimun à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    

        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Oursins'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("__________________")
        feedback.pushInfo("Oursins")       
        feedback.pushInfo(" ")
        feedback.pushInfo("Variables")        
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))

        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("Filtrage")
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km (0 pour non défini)".format(maxDistanceKM))
        feedback.pushInfo("__________________")
        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 
        # feedback.pushInfo("      • valeur maximale :    {0}".format(maxValue))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         distance])
                        pr.addFeature(f)
            except:
                # commune manquante dans le fond de carte
                pass
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               vl.fields(), QgsWkbTypes.LineString, vl.crs())


        # vl.triggerRepaint()        
        features = vl.getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
            
        self.dest_id = dest_id
        
        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}
        
    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        output.renderer().symbol().symbolLayers()[0].setWidth(0.1)
        output.renderer().symbol().symbolLayers()[0].setColor(QColor('Black'))
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'automaticflowlines'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Oursins')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateLinesAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/oursins.png')
        

class ShortenLinesAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    DISTANCE = 'DISTANCE'
    TARGET = 'TARGET'
    STOCK = 'STOCK'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Fond d''oursins'),
                [QgsProcessing.TypeVectorLine]
            )
        ) 
        self.targetList = [self.tr('à partir de l''origine'), self.tr('à partir de la destination')]
        self.addParameter(QgsProcessingParameterEnum(
                self.TARGET,
                self.tr('Couper les lignes...'),
                defaultValue = 0,
                options=self.targetList
            )
        )
        self.addParameter(QgsProcessingParameterNumber(
                self.DISTANCE,
                self.tr('Distance (en km)'),
                defaultValue=10,
                minValue = 1,
                optional=False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de stock/effectifs'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Oursins réduits'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputLayer = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        radius = self.parameterAsDouble(parameters, self.DISTANCE , context)
        target = self.parameterAsInt( parameters, self.TARGET, context )
        if target !=0 :
            target = -1
        feedback.pushInfo("      • Distance :    {0}".format(radius))
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               inputLayer.fields(), QgsWkbTypes.LineString, inputLayer.crs())             

        # features = result['OUTPUT'].getFeatures()
        stockField = self.parameterAsString(parameters, self.STOCK , context)

        for feature in inputLayer.getFeatures():
            if stockField != "":
                stockFieldIndex = inputLayer.fields().indexOf(stockField)

            bufferCenter = QgsGeometry(feature.geometry().get()[target])          
            bufferPolygon = bufferCenter.buffer(radius*1000, 5)
            intersectLine = QgsGeometry.intersection(feature.geometry(), bufferPolygon)
            feature.setGeometry(intersectLine)
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
                                               
        return {self.OUTPUT_LAYER: dest_id}
        
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'shortenlines'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Raccourcir les oursins')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return ShortenLinesAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/oursins.png')

class CreateArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'
    SMART_ARROWS="SMART_ARROWS"
    ADD_LEGEND='ADD_LEGEND'
    OUTPUT2 = 'OUTPUT2'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
        except:
            maxValue = 0
            maxWidth = 0

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.SMART_ARROWS,
                self.tr('Flèches réduites => nécessite un fond de géolocalisation de type polygone'),
                defaultValue=False))
                
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )  
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.ADD_LEGEND,
                self.tr('Ajouter une légende'),
                defaultValue=True))
                
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT2, 
                self.tr('Légende'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        )
        
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))

        addLegend = self.parameterAsBool(parameters,self.ADD_LEGEND,context)
        
        # feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            buffer = processing.run("native:buffer", 
                            {'INPUT':geometryLayer,
                             'DISTANCE':QgsProperty.fromExpression(
                                        '-sqrt(area($geometry)/(10*pi()))'),
                             'SEGMENTS':5,
                             'END_CAP_STYLE':0,
                             'JOIN_STYLE':0,
                             'MITER_LIMIT':2,
                             'DISSOLVE':False,
                             'OUTPUT':'memory:'},
                         feedback = None)
            singleParts = processing.run("native:multiparttosingleparts", 
                            {'INPUT':buffer['OUTPUT'],
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            feedback.pushInfo("      • singleParts['OUTPUT'] :    {0}".format(singleParts))
            feedback.pushInfo("      • geographicIdName :    {0}".format(geographicIdName))
            sql = processing.run("qgis:executesql", 
                            {'INPUT_DATASOURCES':singleParts['OUTPUT'],
                             'INPUT_QUERY':'select *,max(st_area(geometry)) as area from input1 group by {0}'.format(geographicIdName),
                             'INPUT_UID_FIELD':'',
                             'INPUT_GEOMETRY_FIELD':'',
                             'INPUT_GEOMETRY_TYPE':4,
                             'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                             'OUTPUT':'memory:'},
                         feedback = None)
                             

                             
            codgeoIndex = sql['OUTPUT'].fields().indexOf(geographicIdName)                             
            features = sql['OUTPUT'].getFeatures()
        else:
            features = geometryLayer.getFeatures()
            
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}

        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid
        feedback.pushInfo('____________________')
        feedback.pushInfo('Flèches joingnantes avec échelle automatique')
        feedback.pushInfo(' ')
        feedback.pushInfo("      Variables")
        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • Origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • Destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • Flux :    {0}, [{1}]".format(valueField,valueFieldIndex+1))

        feedback.pushInfo("      Filtrage")
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Flux minimum :    {0}".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale (0 pour non défini) :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("WIDTH", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 

        self.maxValue = maxValue
        self.maxWidth = (maximumExtent)/30
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
   
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         abs(value)*self.maxWidth/self.maxValue,
                                         distance])
                        pr.addFeature(f)
            except:
                # commune non présente dans le fond de carte
                pass
                    
                    # 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)        
        # Add features to the sink
        # (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
        #                                        vl.fields(), QgsWkbTypes.LineString, vl.crs())
                                               

        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            lineOrigin = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[vl,sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.origine = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'},
                         feedback = None)
                    
            lineDestination = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[lineOrigin['OUTPUT'],sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.dest = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'},
                         feedback = None)
                    
            singleParts = processing.run("native:multiparttosingleparts", 
                    {'INPUT':lineDestination['OUTPUT'],
                     'OUTPUT':'memory:'})
                    
            arrow = processing.run("qgis:executesql", 
                    {'INPUT_DATASOURCES':[geometryLayer,singleParts['OUTPUT']],
                     'INPUT_QUERY':'select input2.* from input2 where st_intersects(input2.geometry,(select input1.geometry from input1 where input2.origine = input1.{0})) and st_intersects(input2.geometry,(select input1.geometry from input1 where input2.dest = input1.{0}))'.format(geographicIdName),
                     'INPUT_UID_FIELD':'',
                     'INPUT_GEOMETRY_FIELD':'geometry',
                     'INPUT_GEOMETRY_TYPE':0,
                     'INPUT_GEOMETRY_CRS':None,
                     'OUTPUT':'memory:'},
                         feedback = None)
                     
            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               arrow['OUTPUT'].fields(), QgsWkbTypes.LineString, arrow['OUTPUT'].crs())

            features = arrow['OUTPUT'].getFeatures()

        else:

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                                   vl.fields(), QgsWkbTypes.LineString, vl.crs())

            features = vl.getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id

        if addLegend:  
        
            xLegend = vl.sourceExtent().xMaximum()
            yLegend = (vl.sourceExtent().yMinimum()+vl.sourceExtent().yMaximum())/2
            legendCoords = str(xLegend)+','+str(yLegend)
            result2 = processing.run("thematic:arrowslegend", 
                        {'MAX_VALUE':maxValue,
                        'MAX_WIDTH':self.maxWidth,
                        'VALUES_LIST':'',
                        'XY_LEGEND':legendCoords,
                        'OUTPUT':'memory:'},
                        feedback = None)
                        
            # processing.run("thematic:arrowslegend", {'MAX_VALUE':8800,'MAX_WIDTH':45288,'VALUES_LIST':'','OUTPUT':'memory:'})

            feedback.pushInfo(self.tr('    Valeurs représentées dans la légende :'))
            feedback.pushInfo("     • val1 : {0}".format(maxValue))
            feedback.pushInfo("     • val2 : {0}".format(maxValue/2))
          
            feedback.pushInfo(self.tr('    Coordonnées de la légende :'))             
            feedback.pushInfo("      • X :    {0}".format(xLegend))
            feedback.pushInfo("      • Y :    {0}".format(yLegend))              
            feedback.pushInfo('____________________')
            feedback.pushInfo('')             
            (sink2, dest_id2) = self.parameterAsSink(parameters, self.OUTPUT2, context,
                                               result2['OUTPUT'].fields(), QgsWkbTypes.LineString, result2['OUTPUT'].crs())        
            features = result2['OUTPUT'].getFeatures()
            for feature in features:
                sink2.addFeature(feature, QgsFeatureSink.FastInsert)
                
            # to get hold of the layer in post processing for styling the legend
            self.dest_id2=dest_id2

            return {self.OUTPUT_LAYER: 'dest_id', self.OUTPUT2: 'dest_id2'} 


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        else:
            feedback.pushInfo(self.tr('   Légende non demandée'))   
            feedback.pushInfo('____________________')
            feedback.pushInfo('')
            
            self.dest_id2 =  None
        
            return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/simple_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # expressionString = '"WIDTH"*0.8'.format(self.maxValue, self.maxWidth)
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < maximum("WIDTH"), $length/2, maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        expressionString = '"WIDTH"'.format(self.maxValue, self.maxWidth)
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        output.triggerRepaint()
        
        if self.dest_id2 is not None:
            # Styling the legend
            output = QgsProcessingUtils.mapLayerFromString(self.dest_id2, context)
            path = os.path.dirname(__file__) + '/styles/arrows_legend.qml'
            output.loadNamedStyle(path)
            output.triggerRepaint()    
            return {self.OUTPUT_LAYER: self.dest_id, self.OUTPUT2: self.dest_id2}
        else :
        
            return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'arrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches joignantes avec échelle automatique')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/fleches.png')
        
        
class CreateCustomArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    MAX_VALUE_SCALE = 'MAX_VALUE_SCALE'
    MAX_WIDTH_SCALE = 'MAX_WIDTH_SCALE'
    CODGEO = 'CODGEO'
    SMART_ARROWS="SMART_ARROWS"
    ADD_LEGEND = 'ADD_LEGEND'
    OUTPUT2 = 'OUTPUT2'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
        except:
            maxValue = 0
            maxWidth = 0

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).

        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_VALUE_SCALE,
                self.tr('Valeur maximale échelle'),
                defaultValue=maxValue,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_WIDTH_SCALE,
                self.tr('Largeur maximale des flèches (en mètres)'),
                defaultValue=maxWidth,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.SMART_ARROWS,
                self.tr('Flèches réduites => nécessite un fond de géolocalisation de type polygone'),
                defaultValue=False))
                
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )  
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.ADD_LEGEND,
                self.tr('Ajouter une légende'),
                defaultValue=True))
                
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT2, 
                self.tr('Légende'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        )
        
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        maxValueScale = self.parameterAsInt(parameters,self.MAX_VALUE_SCALE,context)
        maxWidthScale = self.parameterAsInt(parameters,self.MAX_WIDTH_SCALE,context)
        addLegend = self.parameterAsBool(parameters,self.ADD_LEGEND,context)        
        # feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            buffer = processing.run("native:buffer", 
                            {'INPUT':geometryLayer,
                             'DISTANCE':QgsProperty.fromExpression(
                                        '-sqrt(area($geometry)/(10*pi()))'),
                             'SEGMENTS':5,
                             'END_CAP_STYLE':0,
                             'JOIN_STYLE':0,
                             'MITER_LIMIT':2,
                             'DISSOLVE':False,
                             'OUTPUT':'memory:'},
                         feedback = None)
            singleParts = processing.run("native:multiparttosingleparts", 
                            {'INPUT':buffer['OUTPUT'],
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            feedback.pushInfo("      • singleParts['OUTPUT'] :    {0}".format(singleParts))
            feedback.pushInfo("      • geographicIdName :    {0}".format(geographicIdName))
            sql = processing.run("qgis:executesql", 
                            {'INPUT_DATASOURCES':singleParts['OUTPUT'],
                             'INPUT_QUERY':'select *,max(st_area(geometry)) as area from input1 group by {0}'.format(geographicIdName),
                             'INPUT_UID_FIELD':'',
                             'INPUT_GEOMETRY_FIELD':'',
                             'INPUT_GEOMETRY_TYPE':4,
                             'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                             'OUTPUT':'memory:'},
                         feedback = None)
                             

                             
            codgeoIndex = sql['OUTPUT'].fields().indexOf(geographicIdName)                             
            features = sql['OUTPUT'].getFeatures()
        else:
            features = geometryLayer.getFeatures()
            
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        
        coordinatesDictionnary = {}

        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid
        feedback.pushInfo('____________________')
        feedback.pushInfo('Flèches joignantes avec échelle personnalisée')
        feedback.pushInfo(' ')
        feedback.pushInfo("      Variables")
        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • Origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • Destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • Flux :    {0}, [{1}]".format(valueField,valueFieldIndex+1))
        feedback.pushInfo("      Filtrage")
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Flux minimum :    {0}".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale (0 pour non défini) :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("WIDTH", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 
        if maxValueScale ==0:
            self.maxValue = maxValue
        else: 
            self.maxValue = maxValueScale
        if maxWidthScale ==0:
            self.maxWidth = (maximumExtent**(.5))*30
        else:
            self.maxWidth = maxWidthScale
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         abs(value)*self.maxWidth/self.maxValue,
                                         distance])
                        pr.addFeature(f)
            except:
                # commune non présente dans le fond de carte
                pass
                
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)   
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            lineOrigin = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[vl,sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.origine = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'},
                     feedback = None)
                    
            lineDestination = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[lineOrigin['OUTPUT'],sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.dest = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'},
                         feedback = None)
                    
            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               lineDestination['OUTPUT'].fields(), QgsWkbTypes.LineString, lineDestination['OUTPUT'].crs())

            features = lineDestination['OUTPUT'].getFeatures()

        else:

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                                   vl.fields(), QgsWkbTypes.LineString, vl.crs())

            features = vl.getFeatures()
            
        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id
        self.dest_id2 = None

        if addLegend:  
        
            xLegend = vl.sourceExtent().xMaximum()
            yLegend = (vl.sourceExtent().yMinimum()+vl.sourceExtent().yMaximum())/2
            legendCoords = str(xLegend)+','+str(yLegend)
            result2 = processing.run("thematic:arrowslegend", 
                        {'MAX_VALUE':maxValue,
                        'MAX_WIDTH':self.maxWidth,
                        'VALUES_LIST':'',
                        'XY_LEGEND':legendCoords,
                        'OUTPUT':'memory:'},
                        feedback = None)
                        
            # processing.run("thematic:arrowslegend", {'MAX_VALUE':8800,'MAX_WIDTH':45288,'VALUES_LIST':'','OUTPUT':'memory:'})
            feedback.pushInfo(self.tr('Valeurs représentées dans la légende :'))
            feedback.pushInfo("     • val1 : {0}".format(maxValue))
            feedback.pushInfo("     • val2 : {0}".format(maxValue/2))
            feedback.pushInfo(self.tr('Coordonnées de la légende :'))             
            feedback.pushInfo("      • X :    {0}".format(xLegend))
            feedback.pushInfo("      • Y :    {0}".format(yLegend))              
            feedback.pushInfo('____________________')
            feedback.pushInfo('')             
            (sink2, dest_id2) = self.parameterAsSink(parameters, self.OUTPUT2, context,
                                               result2['OUTPUT'].fields(), QgsWkbTypes.LineString, result2['OUTPUT'].crs())        
            features = result2['OUTPUT'].getFeatures()
            for feature in features:
                sink2.addFeature(feature, QgsFeatureSink.FastInsert)
                
            # to get hold of the layer in post processing for styling the legend
            self.dest_id2=dest_id2

            return {self.OUTPUT_LAYER: 'dest_id', self.OUTPUT2: 'dest_id2'} 
        
        else:
            feedback.pushInfo(self.tr('   Légende non demandée'))   
            feedback.pushInfo('____________________')
            feedback.pushInfo('')


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/simple_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # expressionString = '"WIDTH"*0.8'.format(self.maxValue, self.maxWidth)
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < maximum("WIDTH"), $length/2, maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        # expressionString = '"WIDTH"'.format(self.maxValue, self.maxWidth)
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        output.triggerRepaint()
        
        if self.dest_id2 is not None:
            # Styling the legend
            output = QgsProcessingUtils.mapLayerFromString(self.dest_id2, context)
            path = os.path.dirname(__file__) + '/styles/arrows_legend.qml'
            output.loadNamedStyle(path)
            output.triggerRepaint()    
            return {self.OUTPUT_LAYER: self.dest_id, self.OUTPUT2: self.dest_id2}
        else :        
            return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'customarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches joignantes avec échelle personnalisée')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateCustomArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/fleches2.png')
        
class CreateSaphirArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    DIRECTION = 'DIRECTION'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'
    ADD_LEGEND = 'ADD_LEGEND'
    OUTPUT2 = 'OUTPUT2'

    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
            
        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=False
            )
        )
        self.shapes = [self.tr('Entrante / solde'), self.tr('Sortante')]
        self.addParameter(QgsProcessingParameterEnum(
                self.DIRECTION,
                self.tr('Direction des flux'),
                defaultValue = 0,
                options=self.shapes
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).


        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.ADD_LEGEND,
                self.tr('Ajouter une légende'),
                defaultValue=True))
                
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT2, 
                self.tr('Légende'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        )
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        direction = self.parameterAsInt( parameters, self.DIRECTION, context )
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        addLegend = self.parameterAsBool(parameters,self.ADD_LEGEND,context)
       
  
        feedback.pushInfo('____________________')
        feedback.pushInfo(self.tr('   Flèches Saphir avec échelle automatique'))   
        feedback.pushInfo('')       

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo(self.tr('Variables'))  
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))
        feedback.pushInfo(self.tr('Filtrage'))  
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km (0 pour non défini)".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()])

            
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
            pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
            
            if pointA != pointB and (value >= minValue or minValue ==0):
            
                line = (pointA,pointB)
                d = QgsDistanceArea()
                distance = d.measureLine(pointA,pointB)/1000
                if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                    f = QgsFeature()
                    f.setGeometry(QgsGeometry.fromPolylineXY(line))
                    f.setAttributes([elem.attributes()[originFieldIndex],
                                     elem.attributes()[destinationFieldIndex],
                                     value,
                                     distance])
                    pr.addFeature(f)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)  
        minDistance = min([abs(item.attributes()[3]) for item in vl.getFeatures()])*.8
        self.maxWidth = 1000*minDistance/3
        self.maxValue = maxValue
        
        varTexte = u' abs(\"FLUX\") * {0}/{1}'.format(self.maxWidth,self.maxValue)
        widthAttribute = processing.run("qgis:fieldcalculator", 
                                {'INPUT':vl,
                                 'FIELD_NAME':'WIDTH',
                                 'FIELD_TYPE':0,
                                 'FIELD_LENGTH':10,
                                 'FIELD_PRECISION':3,
                                 'NEW_FIELD':True,
                                 'FORMULA':varTexte,
                                 'OUTPUT':'memory:'},
                          feedback=None)
                          
        self.maxLength = minDistance*1000
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxLength',self.maxLength)
        
        feedback.pushInfo("Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))   
        feedback.pushInfo("      • longueur des flèches :    {0} m".format(self.maxLength)) 
        if direction == 0:
            startDistance = 0
            endDistance = minDistance*1000
        else:
            startDistance = QgsProperty.fromExpression('length( $geometry)-{0}*1000'.format(minDistance))
            endDistance = QgsProperty.fromExpression('length( $geometry)')
            
        shortLines =processing.run("native:linesubstring", 
                                {'INPUT':widthAttribute['OUTPUT'],
                                 'START_DISTANCE':startDistance,
                                 'END_DISTANCE':endDistance,
                                 'OUTPUT':'memory:'},
                         feedback = None)                         
        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               shortLines['OUTPUT'].fields(), QgsWkbTypes.LineString, shortLines['OUTPUT'].crs())

        features = shortLines['OUTPUT'].getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id

        if addLegend:  
        
            xLegend = vl.sourceExtent().xMaximum()
            yLegend = (vl.sourceExtent().yMinimum()+vl.sourceExtent().yMaximum())/2
            legendCoords = str(xLegend)+','+str(yLegend)
            result2 = processing.run("thematic:arrowslegend", 
                        {'MAX_VALUE':maxValue,
                        'MAX_WIDTH':self.maxWidth,
                        'VALUES_LIST':'',
                        'XY_LEGEND':legendCoords,
                        'OUTPUT':'memory:'},
                        feedback = None)
                        
            # processing.run("thematic:arrowslegend", {'MAX_VALUE':8800,'MAX_WIDTH':45288,'VALUES_LIST':'','OUTPUT':'memory:'})
            feedback.pushInfo(self.tr('Valeurs représentées dans la légende :'))
            feedback.pushInfo("     • val1 : {0}".format(maxValue))
            feedback.pushInfo("     • val2 : {0}".format(maxValue/2))
            feedback.pushInfo(self.tr('Coordonnées de la légende :'))             
            feedback.pushInfo("      • X :    {0}".format(xLegend))
            feedback.pushInfo("      • Y :    {0}".format(yLegend))              
            feedback.pushInfo('____________________')
            feedback.pushInfo('')             
            (sink2, dest_id2) = self.parameterAsSink(parameters, self.OUTPUT2, context,
                                               result2['OUTPUT'].fields(), QgsWkbTypes.LineString, result2['OUTPUT'].crs())        
            features = result2['OUTPUT'].getFeatures()
            for feature in features:
                sink2.addFeature(feature, QgsFeatureSink.FastInsert)
                
            # to get hold of the layer in post processing for styling the legend
            self.dest_id2=dest_id2

            return {self.OUTPUT_LAYER: 'dest_id', self.OUTPUT2: 'dest_id2'} 


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        else:
            feedback.pushInfo(self.tr('Légende non demandée'))   
            feedback.pushInfo('____________________')
            feedback.pushInfo('')
            
            self.dest_id2 =  None
        
            return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/saphir_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < maximum("WIDTH"), $length/2, maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        
        output.triggerRepaint()
        if self.dest_id2 is not None:
            # Styling the legend
            output = QgsProcessingUtils.mapLayerFromString(self.dest_id2, context)
            path = os.path.dirname(__file__) + '/styles/arrows_legend.qml'
            output.loadNamedStyle(path)
            output.triggerRepaint()    
            return {self.OUTPUT_LAYER: self.dest_id, self.OUTPUT2: self.dest_id2}
        else :
            return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'saphirarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches saphir avec échelle automatique')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateSaphirArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/saphir.png')


class CreateCustomSaphirArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    DIRECTION = 'DIRECTION'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    MAX_VALUE_SCALE = 'MAX_VALUE_SCALE'
    MAX_WIDTH_SCALE = 'MAX_WIDTH_SCALE'
    MAX_LENGTH_SCALE = 'MAX_LENGTH_SCALE'
    CODGEO = 'CODGEO'
    ADD_LEGEND = 'ADD_LEGEND'
    OUTPUT2 = 'OUTPUT2'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
            maxLength = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxLength')
        except:
            maxValue = 0
            maxWidth = 0
            maxLength = 0
            
        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=False
            )
        )
        self.shapes = [self.tr('Entrante / solde'), self.tr('Sortante')]
        self.addParameter(QgsProcessingParameterEnum(
                self.DIRECTION,
                self.tr('Direction des flux'),
                defaultValue = 0,
                options=self.shapes
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_VALUE_SCALE,
                self.tr('Valeur maximale échelle'),
                defaultValue=maxValue,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_WIDTH_SCALE,
                self.tr('Largeur maximale des flèches (en mètres)'),
                defaultValue=maxWidth,
                minValue=0,
                optional=False
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_LENGTH_SCALE,
                self.tr('Longueur des flèches (en mètres)'),
                defaultValue=maxLength,
                minValue=0,
                optional=False
            )
        )
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.ADD_LEGEND,
                self.tr('Ajouter une légende'),
                defaultValue=True))
                        
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT2, 
                self.tr('Légende'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        )
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        direction = self.parameterAsInt( parameters, self.DIRECTION, context )
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        maxValueScale = self.parameterAsInt(parameters,self.MAX_VALUE_SCALE,context)
        maxWidthScale = self.parameterAsInt(parameters,self.MAX_WIDTH_SCALE,context)
        maxLengthScale = self.parameterAsInt(parameters,self.MAX_LENGTH_SCALE,context)
        addLegend = self.parameterAsBool(parameters,self.ADD_LEGEND,context)

        feedback.pushInfo('____________________')        
        feedback.pushInfo(self.tr('   Flèches Saphir avec échelle personnalisée'))  
        feedback.pushInfo('')      

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo(self.tr('Variables'))  
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))
        feedback.pushInfo(self.tr('Filtrage'))  
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km (0 pour non défni)".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()])

        if maxValueScale ==0:
            self.maxValue = maxValue
        else: 
            self.maxValue = maxValueScale
            
        # self.maxWidth = (maximumExtent**(.5))*15
        feedback.pushInfo("      • valeur maximale :    {0}".format(maxValue))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
            pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
            
            if pointA != pointB and (value >= minValue or minValue ==0):
            
                line = (pointA,pointB)
                d = QgsDistanceArea()
                distance = d.measureLine(pointA,pointB)/1000
                if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                    f = QgsFeature()
                    f.setGeometry(QgsGeometry.fromPolylineXY(line))
                    f.setAttributes([elem.attributes()[originFieldIndex],
                                     elem.attributes()[destinationFieldIndex],
                                     value,
                                     distance])
                    pr.addFeature(f)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)  
        minDistance = min([abs(item.attributes()[3]) for item in vl.getFeatures()])*.8
        # self.maxWidth = 1000*minDistance/3
        if maxWidthScale ==0:
            self.maxWidth = 1000*minDistance/3
        else:
            self.maxWidth = maxWidthScale
            
        if maxLengthScale == 0:
            self.maxLength = minDistance
        else:
            self.maxLength = maxLengthScale
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxLength',self.maxLength)
        
        feedback.pushInfo("Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        feedback.pushInfo("      • longueur des flèches :    {0} m".format(self.maxLength))   
        
        varTexte = u' abs(\"FLUX\") * {0}/{1}'.format(self.maxWidth,self.maxValue)
        widthAttribute = processing.run("qgis:fieldcalculator", 
                                {'INPUT':vl,
                                 'FIELD_NAME':'WIDTH',
                                 'FIELD_TYPE':0,
                                 'FIELD_LENGTH':10,
                                 'FIELD_PRECISION':3,
                                 'NEW_FIELD':True,
                                 'FORMULA':varTexte,
                                 'OUTPUT':'memory:'},
                          feedback=None)
        
        if direction == 0:
            startDistance = 0
            endDistance = self.maxLength
        else:
            startDistance = QgsProperty.fromExpression('length( $geometry)-{0}'.format(self.maxLength))
            endDistance = QgsProperty.fromExpression('length( $geometry)')

        shortLines =processing.run("native:linesubstring", 
                                {'INPUT':widthAttribute['OUTPUT'],
                                 'START_DISTANCE':startDistance,
                                 'END_DISTANCE':endDistance,
                                 'OUTPUT':'memory:'},
                         feedback = None)                               
        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               shortLines['OUTPUT'].fields(), QgsWkbTypes.LineString, shortLines['OUTPUT'].crs())

        features = shortLines['OUTPUT'].getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id
        if addLegend:  
        
            xLegend = vl.sourceExtent().xMaximum()
            yLegend = (vl.sourceExtent().yMinimum()+vl.sourceExtent().yMaximum())/2
            legendCoords = str(xLegend)+','+str(yLegend)
            result2 = processing.run("thematic:arrowslegend", 
                        {'MAX_VALUE':maxValue,
                        'MAX_WIDTH':self.maxWidth,
                        'VALUES_LIST':'',
                        'XY_LEGEND':legendCoords,
                        'OUTPUT':'memory:'},
                        feedback = None)
                        
            # processing.run("thematic:arrowslegend", {'MAX_VALUE':8800,'MAX_WIDTH':45288,'VALUES_LIST':'','OUTPUT':'memory:'})
            feedback.pushInfo(self.tr('Valeurs représentées dans la légende :'))
            feedback.pushInfo("     • val1 : {0}".format(maxValue))
            feedback.pushInfo("     • val2 : {0}".format(maxValue/2))
            feedback.pushInfo(self.tr('    Coordonnées de la légende :'))             
            feedback.pushInfo("      • X :    {0}".format(xLegend))
            feedback.pushInfo("      • Y :    {0}".format(yLegend))              
            feedback.pushInfo('____________________')
            feedback.pushInfo('')             
            (sink2, dest_id2) = self.parameterAsSink(parameters, self.OUTPUT2, context,
                                               result2['OUTPUT'].fields(), QgsWkbTypes.LineString, result2['OUTPUT'].crs())        
            features = result2['OUTPUT'].getFeatures()
            for feature in features:
                sink2.addFeature(feature, QgsFeatureSink.FastInsert)
                
            # to get hold of the layer in post processing for styling the legend
            self.dest_id2=dest_id2

            return {self.OUTPUT_LAYER: 'dest_id', self.OUTPUT2: 'dest_id2'} 


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        else:
            feedback.pushInfo(self.tr('Légende non demandée'))   
            feedback.pushInfo('____________________')
            feedback.pushInfo('')
            
            self.dest_id2 =  None
        
            return {self.OUTPUT_LAYER: dest_id}


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/saphir_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < maximum("WIDTH"), $length/2, maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        
        output.triggerRepaint()
        
        if self.dest_id2 is not None:
            # Styling the legend
            output = QgsProcessingUtils.mapLayerFromString(self.dest_id2, context)
            path = os.path.dirname(__file__) + '/styles/arrows_legend.qml'
            output.loadNamedStyle(path)
            output.triggerRepaint()    
            return {self.OUTPUT_LAYER: self.dest_id, self.OUTPUT2: self.dest_id2}
        else :
        
            return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'customsaphirarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches saphir avec échelle personnalisée')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateCustomSaphirArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/saphir2.png')
        

class CreateArrowsLegendAlgorithm(QgsProcessingAlgorithm):
    """
    Gerenate a legend layer for proportional symbols
    (circles, diamons and squares)
    """
    
    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    
    OUTPUT = 'OUTPUT'
    COLUMNS = 'COLUMNS'
    MAX_WIDTH = 'MAX_WIDTH'
    MAX_VALUE = 'MAX_VALUE'
    VALUES_LIST = 'VALUES_LIST'
    XY_LEGEND = 'XY_LEGEND'
    
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        
        # Use the parameters of an eventualy previous analysis
        project = QgsProject.instance()
        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
            
        except:
            # if not
            maxValue = 1
            maxWidth = 1
            
        
        # Parametres in UI
        
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_VALUE,
                self.tr('Valeur maximale'),
                minValue=0,
                defaultValue = maxValue,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_WIDTH,
                self.tr('Largeur associée en mètres'),
                minValue=0,
                defaultValue = maxWidth,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterString(
                self.VALUES_LIST,
                self.tr('Valeurs à représenter (exemple : 3000;1000;300)'),
                optional=True
            )
        )
        
        # Advanced parameters only for batch processing (Legend position)
        
        params = []
        
        params.append(
            QgsProcessingParameterString(
                self.XY_LEGEND,
                self.tr('Position X,Y de la légende'),
                optional=True
            )
        )
        
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagHidden)
            self.addParameter(param)

            
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        
        # Output layer
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT, 
                self.tr('Légende'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        )        
        
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        
        # parameters initialisation
        
        # invert order of representation -> squares, diamonds, circles/ovals
        representation = 1
        maxWidth = self.parameterAsInt(parameters,self.MAX_WIDTH,context)
        maxValue = self.parameterAsInt(parameters,self.MAX_VALUE,context)  
        valueList = self.parameterAsString(parameters, self.VALUES_LIST , context)
        legendCustomValues = valueList.strip().replace(';',' ').split()
        coordsLegendText = self.parameterAsString(parameters, self.XY_LEGEND , context)
        
        project = QgsProject.instance()
        
        # save the parameters as project variable
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_circlesRepresentation',representation)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_circlesMaxValue',maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_circlesmaxWidth',maxWidth)
        
        # set a global variable for layer styling in postprocessing
        self.representation = representation
        
        feedback.pushInfo('____________________')
        feedback.pushInfo(self.tr("Génération d'une légende flèches :"))
        feedback.pushInfo('')
        feedback.pushInfo(self.tr("Échelle des flèches :"))  
        feedback.pushInfo(self.tr('     • Val : {0}'.format(maxValue)))   
        feedback.pushInfo(self.tr('     • Largeur : {0}'.format(maxWidth)))              


        # set the legend  coordinates
        
        if len(coordsLegendText) >0 :
            # with coordinates parameters
            legendCoordsList = coordsLegendText.strip().split(',')
            coordsLegend =[float(item) for item in legendCoordsList ]
            xLegend = coordsLegend[0]
            yLegend = coordsLegend[1]
        else:
            # no coordinates given
            # -> center the legend in the canevas
            canevasExtent = iface.mapCanvas().extent()
            xLegend = (canevasExtent.xMaximum()+canevasExtent.xMinimum() )/2
            yLegend = (canevasExtent.yMaximum()+canevasExtent.yMinimum() )/2

        # coeff = maxWidth * (math.pi/maxValue)**.5
        Value = maxValue
        
        # values to represent in the legend
        
            
        if len(legendCustomValues) > 0:
            try:
                # legendCustomValues = sorted(legendCustomValues, reverse= True)
                legendCustomValues =sorted([float(item) for item in legendCustomValues ], reverse = True)
                feedback.pushInfo(self.tr('     • Liste des valeurs à afficher : {0}'.format(legendCustomValues))) 
            except:
                feedback.reportError(self.tr('     • Saisie de la liste des valeurs à afficher incorrecte :  {0}'.format(legendCustomValues)))
                legendCustomValues = (maxValue,maxValue/2)
                feedback.reportError(self.tr('     • Remplacement par les valeurs par défaut : {0}'.format(legendCustomValues)))
        else:
            legendCustomValues = (maxValue,maxValue/2)
            feedback.pushInfo(self.tr('     • Liste des valeurs à afficher : {0}'.format(legendCustomValues))) 
        
        # create a temporary line layer
        crsString = project.crs().authid()
        vl2 = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        from qgis.PyQt.QtCore import QVariant
        pr2 = vl2.dataProvider()
        pr2.addAttributes([QgsField("VAL", QVariant.Double),
                          QgsField("WIDTH", QVariant.Double)])
        vl2.updateFields() 
        
        x = xLegend
        y = yLegend
            
        for i in legendCustomValues:
            width = i * maxWidth/maxValue
            f = QgsFeature()
            f.setGeometry(QgsGeometry.fromPolyline([QgsPoint(x,y),QgsPoint(x+maxWidth*2,y)]))
            f.setAttributes([i, width])
            pr2.addFeature(f)
            y -= (width + 0.2*maxWidth) 
        vl2.updateExtents() 
        
        feedback.pushInfo(self.tr('Coordonnées de la légende :'))
        feedback.pushInfo("      • X :    {0}".format(xLegend))
        feedback.pushInfo("      • Y :    {0}".format(yLegend))
        
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                               pr2.fields(), QgsWkbTypes.LineString , vl2.crs()) 
        
                          
        feedback.pushInfo('____________________')
        feedback.pushInfo('')
             
        # Add features to the sink
        features = vl2.getFeatures()
        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
            
        # Return the results of the algorithm. 
        
        self.dest_id = dest_id
        return {self.OUTPUT: dest_id}
        
    def postProcessAlgorithm(self, context, feedback):


        # Apply a symbology to the legend
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/arrows_legend.qml'        
        output.loadNamedStyle(path)
        output.triggerRepaint()
        return {self.OUTPUT: self.dest_id}

        
    def shortHelpString(self):
        return self.tr("...")

                       
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'arrowslegend'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Générer une légende seule')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateArrowsLegendAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/fleches_leg.png')
