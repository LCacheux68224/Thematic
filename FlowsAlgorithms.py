# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Thematic
                                 A QGIS plugin
 Thematic cartography tools for processing
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-19
        copyright            : (C) 2018 by Lionel Cacheux
        email                : lionel.cacheux@gmx.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lionel Cacheux'
__date__ = '2018-07-19'
__copyright__ = '(C) 2018 by Lionel Cacheux'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication
from qgis.PyQt.QtCore import QVariant
import os, math
from PyQt5.QtGui import (QIcon, QColor)
from qgis.core import (QgsProcessing,
                       QgsProject,
                       QgsMessageLog,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterVectorLayer,
                       QgsCoordinateReferenceSystem,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsFeatureRequest,
                       QgsField,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterField,
                       QgsProcessingParameterDefinition,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsGeometry,
                       QgsDistanceArea,
                       QgsSimpleLineSymbolLayer,
                       QgsProcessingUtils,
                       QgsArrowSymbolLayer,
                       QgsSymbol,
                       QgsProcessingParameterBoolean,
                       QgsExpressionContextUtils,
                       QgsProperty,
                       QgsWkbTypes)
import processing


class CreateLinesAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'
    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        '''
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )
        '''
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimun à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    

        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Oursins'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))

        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 
        feedback.pushInfo("      • valeur maximale :    {0}".format(maxValue))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         distance])
                        pr.addFeature(f)
            except:
                # commune manquante dans le fond de carte
                pass
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               vl.fields(), QgsWkbTypes.LineString, vl.crs())
        feedback.pushInfo("      • sink :    {0}".format(type(context)))

        # vl.triggerRepaint()        
        features = vl.getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
            
        self.dest_id = dest_id


        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}
        
    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        output.renderer().symbol().symbolLayers()[0].setWidth(0.1)
        output.renderer().symbol().symbolLayers()[0].setColor(QColor('Black'))
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'automaticflowlines'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Oursins')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateLinesAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/oursins.png')
        

class ShortenLinesAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    DISTANCE = 'DISTANCE'
    TARGET = 'TARGET'
    STOCK = 'STOCK'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Fond d''oursins'),
                [QgsProcessing.TypeVectorLine]
            )
        ) 
        self.targetList = [self.tr('à partir de l''origine'), self.tr('à partir de la destination')]
        self.addParameter(QgsProcessingParameterEnum(
                self.TARGET,
                self.tr('Couper les lignes...'),
                defaultValue = 0,
                options=self.targetList
            )
        )
        self.addParameter(QgsProcessingParameterNumber(
                self.DISTANCE,
                self.tr('Distance (en km)'),
                defaultValue=10,
                minValue = 1,
                optional=False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de stock/effectifs'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Oursins réduits'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputLayer = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        radius = self.parameterAsDouble(parameters, self.DISTANCE , context)
        target = self.parameterAsInt( parameters, self.TARGET, context )
        if target !=0 :
            target = -1
        feedback.pushInfo("      • Distance :    {0}".format(radius))
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               inputLayer.fields(), QgsWkbTypes.LineString, inputLayer.crs())             

        # features = result['OUTPUT'].getFeatures()
        stockField = self.parameterAsString(parameters, self.STOCK , context)

        for feature in inputLayer.getFeatures():
            if stockField != "":
                stockFieldIndex = inputLayer.fields().indexOf(stockField)

            bufferCenter = QgsGeometry(feature.geometry().get()[target])          
            bufferPolygon = bufferCenter.buffer(radius*1000, 5)
            intersectLine = QgsGeometry.intersection(feature.geometry(), bufferPolygon)
            feature.setGeometry(intersectLine)
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
                                               
        return {self.OUTPUT_LAYER: dest_id}
        
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'shortenlines'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Raccourcir les oursins')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return ShortenLinesAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/oursins.png')

class CreateArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'
    SMART_ARROWS="SMART_ARROWS"

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
        except:
            maxValue = 0
            maxWidth = 0

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.SMART_ARROWS,
                self.tr('Flèches selon polygones'),
                defaultValue=False))
                
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )  

        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))

        
        # feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            buffer = processing.run("native:buffer", 
                            {'INPUT':geometryLayer,
                             'DISTANCE':QgsProperty.fromExpression(
                                        '-sqrt(area($geometry)/(10*pi()))'),
                             'SEGMENTS':5,
                             'END_CAP_STYLE':0,
                             'JOIN_STYLE':0,
                             'MITER_LIMIT':2,
                             'DISSOLVE':False,
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            singleParts = processing.run("native:multiparttosingleparts", 
                            {'INPUT':buffer['OUTPUT'],
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            feedback.pushInfo("      • singleParts['OUTPUT'] :    {0}".format(singleParts))
            feedback.pushInfo("      • geographicIdName :    {0}".format(geographicIdName))
            sql = processing.run("qgis:executesql", 
                            {'INPUT_DATASOURCES':singleParts['OUTPUT'],
                             'INPUT_QUERY':'select *,max(st_area(geometry)) as area from input1 group by {0}'.format(geographicIdName),
                             'INPUT_UID_FIELD':'',
                             'INPUT_GEOMETRY_FIELD':'',
                             'INPUT_GEOMETRY_TYPE':4,
                             'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                             'OUTPUT':'memory:'},
                         feedback = feedback)
                             

                             
            codgeoIndex = sql['OUTPUT'].fields().indexOf(geographicIdName)                             
            features = sql['OUTPUT'].getFeatures()
        else:
            features = geometryLayer.getFeatures()
            
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}

        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        feedback.pushInfo("      Variables")
        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • Origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • Destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • Flux :    {0}, [{1}]".format(valueField,valueFieldIndex+1))
        feedback.pushInfo("      Filtrage")
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Flux minimum :    {0}".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale (0 pour non défini) :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("WIDTH", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 

        self.maxValue = maxValue
        self.maxWidth = (maximumExtent**(.5))*30
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         abs(value)*self.maxWidth/self.maxValue,
                                         distance])
                        pr.addFeature(f)
            except:
                # commune non présente dans le fond de carte
                pass
                    
                    # 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)        
        # Add features to the sink
        # (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
        #                                        vl.fields(), QgsWkbTypes.LineString, vl.crs())
                                               

        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            lineOrigin = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[vl,sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.origine = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'})
                    
            lineDestination = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[lineOrigin['OUTPUT'],sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.dest = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'})
                    
            singleParts = processing.run("native:multiparttosingleparts", 
                    {'INPUT':lineDestination['OUTPUT'],
                     'OUTPUT':'memory:'})
                    
            arrow = processing.run("qgis:executesql", 
                    {'INPUT_DATASOURCES':[geometryLayer,singleParts['OUTPUT']],
                     'INPUT_QUERY':'select input2.* from input2 where st_intersects(input2.geometry,(select input1.geometry from input1 where input2.origine = input1.{0})) and st_intersects(input2.geometry,(select input1.geometry from input1 where input2.dest = input1.{0}))'.format(geographicIdName),
                     'INPUT_UID_FIELD':'',
                     'INPUT_GEOMETRY_FIELD':'geometry',
                     'INPUT_GEOMETRY_TYPE':0,
                     'INPUT_GEOMETRY_CRS':None,
                     'OUTPUT':'memory:'})
                     
            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               arrow['OUTPUT'].fields(), QgsWkbTypes.LineString, arrow['OUTPUT'].crs())

            features = arrow['OUTPUT'].getFeatures()

        else:

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                                   vl.fields(), QgsWkbTypes.LineString, vl.crs())

            features = vl.getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id




        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/simple_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # expressionString = '"WIDTH"*0.8'.format(self.maxValue, self.maxWidth)
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < "WIDTH"+.1*maximum("WIDTH"), $length/2, "WIDTH"+.1*maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        expressionString = '"WIDTH"'.format(self.maxValue, self.maxWidth)
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString('0.5*"WIDTH"+.2*maximum("WIDTH")')
        
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'arrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches joignantes avec échelle automatique')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/iconFlechesJoignantes.png')
        
        
class CreateCustomArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    MAX_VALUE_SCALE = 'MAX_VALUE_SCALE'
    MAX_WIDTH_SCALE = 'MAX_WIDTH_SCALE'
    CODGEO = 'CODGEO'
    SMART_ARROWS="SMART_ARROWS"

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
        except:
            maxValue = 0
            maxWidth = 0

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).

        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_VALUE_SCALE,
                self.tr('Valeur maximale échelle'),
                defaultValue=maxValue,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_WIDTH_SCALE,
                self.tr('Largeur maximale des flèches (en mètres)'),
                defaultValue=maxWidth,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterBoolean(self.SMART_ARROWS,
                self.tr('Flèches selon polygones'),
                defaultValue=False))
                
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )  

        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        maxValueScale = self.parameterAsInt(parameters,self.MAX_VALUE_SCALE,context)
        maxWidthScale = self.parameterAsInt(parameters,self.MAX_WIDTH_SCALE,context)
        
        # feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            buffer = processing.run("native:buffer", 
                            {'INPUT':geometryLayer,
                             'DISTANCE':QgsProperty.fromExpression(
                                        '-sqrt(area($geometry)/(20*pi()))'),
                             'SEGMENTS':5,
                             'END_CAP_STYLE':0,
                             'JOIN_STYLE':0,
                             'MITER_LIMIT':2,
                             'DISSOLVE':False,
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            singleParts = processing.run("native:multiparttosingleparts", 
                            {'INPUT':buffer['OUTPUT'],
                             'OUTPUT':'memory:'},
                         feedback = feedback)
            feedback.pushInfo("      • singleParts['OUTPUT'] :    {0}".format(singleParts))
            feedback.pushInfo("      • geographicIdName :    {0}".format(geographicIdName))
            sql = processing.run("qgis:executesql", 
                            {'INPUT_DATASOURCES':singleParts['OUTPUT'],
                             'INPUT_QUERY':'select *,max(st_area(geometry)) as area from input1 group by {0}'.format(geographicIdName),
                             'INPUT_UID_FIELD':'',
                             'INPUT_GEOMETRY_FIELD':'',
                             'INPUT_GEOMETRY_TYPE':4,
                             'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                             'OUTPUT':'memory:'},
                         feedback = feedback)
                             

                             
            codgeoIndex = sql['OUTPUT'].fields().indexOf(geographicIdName)                             
            features = sql['OUTPUT'].getFeatures()
        else:
            features = geometryLayer.getFeatures()
            
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid
        feedback.pushInfo("      Variables")
        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • Origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • Destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • Flux :    {0}, [{1}]".format(valueField,valueFieldIndex+1))
        feedback.pushInfo("      Filtrage")
        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Flux minimum :    {0}".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale (0 pour non défini) :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("WIDTH", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()]) 
        if maxValueScale ==0:
            self.maxValue = maxValue
        else: 
            self.maxValue = maxValueScale
        if maxWidthScale ==0:
            self.maxWidth = (maximumExtent**(.5))*30
        else:
            self.maxWidth = maxWidthScale
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            try:
                pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
                pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
                
                if pointA != pointB and (value >= minValue or minValue ==0):
                
                    line = (pointA,pointB)
                    d = QgsDistanceArea()
                    distance = d.measureLine(pointA,pointB)/1000
                    if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                        f = QgsFeature()
                        f.setGeometry(QgsGeometry.fromPolylineXY(line))
                        f.setAttributes([elem.attributes()[originFieldIndex],
                                         elem.attributes()[destinationFieldIndex],
                                         value, 
                                         abs(value)*self.maxWidth/self.maxValue,
                                         distance])
                        pr.addFeature(f)
            except:
                # commune non présente dans le fond de carte
                pass
                
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)   
        
        if self.parameterAsBool(parameters,self.SMART_ARROWS,context):
            lineOrigin = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[vl,sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.origine = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'})
                    
            lineDestination = processing.run("qgis:executesql",
                    {'INPUT_DATASOURCES':[lineOrigin['OUTPUT'],sql['OUTPUT']],
                    'INPUT_QUERY':'select a.ORIGINE, a.DEST, a.FLUX, a.WIDTH, a.DIST_KM , st_difference(a.geometry, b.geometry) as geometry from input1 as a left join input2 as b on a.dest = b.{0}'.format(geographicIdName),
                    'INPUT_UID_FIELD':'',
                    'INPUT_GEOMETRY_FIELD':'',
                    'INPUT_GEOMETRY_TYPE':4,
                    'INPUT_GEOMETRY_CRS':geometryLayer.crs(),
                    'OUTPUT':'memory:'})
                    
            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               lineDestination['OUTPUT'].fields(), QgsWkbTypes.LineString, lineDestination['OUTPUT'].crs())

            features = lineDestination['OUTPUT'].getFeatures()

        else:

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                                   vl.fields(), QgsWkbTypes.LineString, vl.crs())

            features = vl.getFeatures()
            
        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id




        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/simple_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = '"WIDTH"'
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        # expressionString = '"WIDTH"*0.8'.format(self.maxValue, self.maxWidth)
        # expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString('if($length/2 < "WIDTH"+.1*maximum("WIDTH"), $length/2, "WIDTH"+.1*maximum("WIDTH"))')
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString('0.5*"WIDTH"+.1*maximum("WIDTH")')
        
        expressionString = '"WIDTH"'.format(self.maxValue, self.maxWidth)
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString('0.5*"WIDTH"+.2*maximum("WIDTH")')
        
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'customarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches joignantes avec échelle personnalisée')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateCustomArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/iconFlechesJoignantes.png')
        
class CreateSaphirArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    DIRECTION = 'DIRECTION'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    CODGEO = 'CODGEO'

    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
            
        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=False
            )
        )
        self.shapes = [self.tr('Entrante / solde'), self.tr('Sortante')]
        self.addParameter(QgsProcessingParameterEnum(
                self.DIRECTION,
                self.tr('Direction des flux'),
                defaultValue = 0,
                options=self.shapes
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).


        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    
        
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        direction = self.parameterAsInt( parameters, self.DIRECTION, context )
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        
        # feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}

        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))

        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()])

            
        # self.maxWidth = (maximumExtent**(.5))*15
        feedback.pushInfo("      • valeur maximale :    {0}".format(maxValue))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
            pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
            
            if pointA != pointB and (value >= minValue or minValue ==0):
            
                line = (pointA,pointB)
                d = QgsDistanceArea()
                distance = d.measureLine(pointA,pointB)/1000
                if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                    f = QgsFeature()
                    f.setGeometry(QgsGeometry.fromPolylineXY(line))
                    f.setAttributes([elem.attributes()[originFieldIndex],
                                     elem.attributes()[destinationFieldIndex],
                                     value,
                                     distance])
                    pr.addFeature(f)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)  
        minDistance = min([abs(item.attributes()[3]) for item in vl.getFeatures()])*.8
        self.maxWidth = 1000*minDistance/3

        self.maxValue = maxValue

        self.maxLength = minDistance*1000
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxLength',self.maxLength)
        
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))   
        
        if direction == 0:
            startDistance = 0
            endDistance = minDistance*1000
        else:
            startDistance = QgsProperty.fromExpression('length( $geometry)-{0}*1000'.format(minDistance))
            endDistance = QgsProperty.fromExpression('length( $geometry)')
            
        shortLines =processing.run("native:linesubstring", 
                                {'INPUT':vl,
                                 'START_DISTANCE':startDistance,
                                 'END_DISTANCE':endDistance,
                                 'OUTPUT':'memory:'})                         
        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               vl.fields(), QgsWkbTypes.LineString, vl.crs())

        features = shortLines['OUTPUT'].getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id




        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/saphir_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString(expressionString)
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString(expressionString)
        
        expressionString = '0)'
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString(expressionString)        
        
        
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'saphirarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches saphir avec échelle automatique')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateSaphirArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/saphir.png')


class CreateCustomSaphirArrowsAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT_LAYER = 'OUTPUT_LAYER'
    INPUT = 'INPUT'
    ORIGIN = 'ORIGIN'
    DESTINATION = 'DESTINATION'
    STOCK = 'STOCK'
    INPUT2 = 'INPUT2'
    DIRECTION = 'DIRECTION'
    MIN_FLOW = 'MIN_FLOW'
    MAX_DIST = 'MAX_DIST'
    MAX_VALUE_SCALE = 'MAX_VALUE_SCALE'
    MAX_WIDTH_SCALE = 'MAX_WIDTH_SCALE'
    MAX_LENGTH_SCALE = 'MAX_LENGTH_SCALE'
    CODGEO = 'CODGEO'
    

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        project = QgsProject.instance()

        try:
            maxValue = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxValue')
            maxWidth = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxWidth')
            maxLength = QgsExpressionContextUtils.projectScope(project).variable('thematic_arrowsMaxLength')
        except:
            maxValue = 0
            maxWidth = 0
            maxLength = 0
            
        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Table de flux'),
                [QgsProcessing.TypeVector]
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.ORIGIN,
                self.tr('Origine'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.DESTINATION,
                self.tr('Destination'),
                None,
                self.INPUT,
                QgsProcessingParameterField.String,
                False
            )
        )
        self.addParameter(QgsProcessingParameterField(
                self.STOCK,
                self.tr('Variable de flux'),
                None,
                self.INPUT,
                QgsProcessingParameterField.Numeric,
                optional=False
            )
        )
        self.shapes = [self.tr('Entrante / solde'), self.tr('Sortante')]
        self.addParameter(QgsProcessingParameterEnum(
                self.DIRECTION,
                self.tr('Direction des flux'),
                defaultValue = 0,
                options=self.shapes
            )
        ) 
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT2,
                self.tr('Fond de géolocalisation'),
                [QgsProcessing.TypeVectorPolygon,QgsProcessing.TypeVectorPoint],
            optional=False
            )
        ) 
        self.addParameter(QgsProcessingParameterField(
                self.CODGEO,
                self.tr('Identifiant géographique'),
                None,
                self.INPUT2,
                QgsProcessingParameterField.String,
                False
            )
        )
        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_VALUE_SCALE,
                self.tr('Valeur maximale échelle'),
                defaultValue=maxValue,
                minValue=0,
                optional=False
            )
        )
        
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_WIDTH_SCALE,
                self.tr('Largeur maximale des flèches (en mètres)'),
                defaultValue=maxWidth,
                minValue=0,
                optional=False
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_LENGTH_SCALE,
                self.tr('Longueur des flèches (en mètres)'),
                defaultValue=maxLength,
                minValue=0,
                optional=False
            )
        )
        params = []
        params.append(
            QgsProcessingParameterNumber(
                self.MIN_FLOW,
                self.tr('Flux minimum à représenter'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )
        
        params.append(
            QgsProcessingParameterNumber(
                self.MAX_DIST,
                self.tr('Distance maximale des flux (en km)'),
                defaultValue=0,
                minValue=0,
                optional=False
            )
        )    

        
        for param in params:
            param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.addParameter(param)
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT_LAYER, 
                self.tr('Flèches'), 
                type=QgsProcessing.TypeVectorPolygon
            )
        ) 
            
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        
        # INPUT = parameters[self.INPUT]
        # print(self.INPUT.extent())
        # print(INPUT)
        
        # definition : flowList(self, flowTable, indexOrigin, indexDestination, indexValue, coordinatesDictionnary, minValue, maxDistance)
        # self.flowList(inputTable, originIndex, destinationIndex, valueIndex, coordinates, minValue, maxDistanceKM)
        
        
        inputTable = self.parameterAsSource(parameters, self.INPUT, context).materialize(QgsFeatureRequest())
        direction = self.parameterAsInt( parameters, self.DIRECTION, context )
        geographicIdName = self.parameterAsString(parameters, self.CODGEO , context)
        geometryLayer = self.parameterAsSource(parameters, self.INPUT2, context).materialize(QgsFeatureRequest())         
        codgeoIndex = geometryLayer.fields().indexOf(geographicIdName)
        layerExtent = geometryLayer.extent()
        maximumExtent = max((layerExtent.xMaximum()-layerExtent.xMinimum()),(layerExtent.yMaximum()-layerExtent.yMinimum()))
        
        maxValueScale = self.parameterAsInt(parameters,self.MAX_VALUE_SCALE,context)
        maxWidthScale = self.parameterAsInt(parameters,self.MAX_WIDTH_SCALE,context)
        maxLengthScale = self.parameterAsInt(parameters,self.MAX_LENGTH_SCALE,context)
        
        feedback.pushInfo("      • maximumExtent :    {0}".format(maximumExtent))        

        crsString = geometryLayer.crs().authid() 
        # extract coordinates of the centroid of the geometryLayer as a dictionary
        coordinatesDictionnary = {}
        features = geometryLayer.getFeatures()
        for elem in features:
            centroid = elem.geometry().centroid().asPoint()
            IDvalue = elem.attributes()[codgeoIndex]
            coordinatesDictionnary[IDvalue] = centroid

        originField = self.parameterAsString(parameters, self.ORIGIN , context)
        originFieldIndex = inputTable.fields().indexOf(originField)
        feedback.pushInfo("      • origine :    {0}, [{1}]".format(originField,originFieldIndex+1))
        
        destinationField = self.parameterAsString(parameters, self.DESTINATION , context)
        destinationFieldIndex = inputTable.fields().indexOf(destinationField)
        feedback.pushInfo("      • destination :    {0}, [{1}]".format(destinationField,destinationFieldIndex+1))
        
        valueField = self.parameterAsString(parameters, self.STOCK , context)
        valueFieldIndex = inputTable.fields().indexOf(valueField)
        feedback.pushInfo("      • effectifs :    {0}, [{1}]".format(valueField,valueFieldIndex+1))

        minValue = self.parameterAsDouble(parameters, self.MIN_FLOW , context)
        feedback.pushInfo("      • Valeur minimale :    {0} individu(s)".format(minValue))
        maxDistanceKM = self.parameterAsDouble(parameters, self.MAX_DIST , context)
        feedback.pushInfo("      • Distance maximale :    {0} km".format(maxDistanceKM))

        vl = QgsVectorLayer("LineString?crs="+crsString, "temp", 'memory')
        pr = vl.dataProvider()
        pr.addAttributes([(QgsField("ORIGINE", QVariant.String)),
                          (QgsField("DEST", QVariant.String)),
                          (QgsField("FLUX", QVariant.Double)),
                          (QgsField("DIST_KM", QVariant.Double))])
        vl.updateFields() 
        
        notInLayer = 0
        
        maxValue = max([abs(item.attributes()[valueFieldIndex]) for item in inputTable.getFeatures()])

        if maxValueScale ==0:
            self.maxValue = maxValue
        else: 
            self.maxValue = maxValueScale
            
        # self.maxWidth = (maximumExtent**(.5))*15
        feedback.pushInfo("      • valeur maximale :    {0}".format(maxValue))
        for elem in inputTable.getFeatures():
            value = float(elem.attributes()[valueFieldIndex])
            pointA = coordinatesDictionnary[elem.attributes()[originFieldIndex]]
            pointB = coordinatesDictionnary[elem.attributes()[destinationFieldIndex]]
            
            if pointA != pointB and (value >= minValue or minValue ==0):
            
                line = (pointA,pointB)
                d = QgsDistanceArea()
                distance = d.measureLine(pointA,pointB)/1000
                if (maxDistanceKM == 0 or distance <= maxDistanceKM):
                    f = QgsFeature()
                    f.setGeometry(QgsGeometry.fromPolylineXY(line))
                    f.setAttributes([elem.attributes()[originFieldIndex],
                                     elem.attributes()[destinationFieldIndex],
                                     value,
                                     distance])
                    pr.addFeature(f)
        vl.updateExtents() 
        vl.renderer().symbol().setWidth(3)  
        minDistance = min([abs(item.attributes()[3]) for item in vl.getFeatures()])*.8
        # self.maxWidth = 1000*minDistance/3
        if maxWidthScale ==0:
            self.maxWidth = 1000*minDistance/3
        else:
            self.maxWidth = maxWidthScale
            
        if maxLengthScale == 0:
            self.maxLength = minDistance
        else:
            self.maxLength = maxLengthScale
            
        project = QgsProject.instance()            
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxValue',self.maxValue)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxWidth',self.maxWidth)
        QgsExpressionContextUtils.setProjectVariable(project,'thematic_arrowsMaxLength',self.maxLength)
        
        feedback.pushInfo("     Échelle :    ")
        feedback.pushInfo("      • valeur maximale :    {0}".format(self.maxValue))
        feedback.pushInfo("      • largeur maximale :    {0} m".format(self.maxWidth))
        feedback.pushInfo("      • longueur des flèches :    {0} m".format(self.maxLength))   
        
        if direction == 0:
            startDistance = 0
            endDistance = self.maxLength
        else:
            startDistance = QgsProperty.fromExpression('length( $geometry)-{0}'.format(self.maxLength))
            endDistance = QgsProperty.fromExpression('length( $geometry)')

        shortLines =processing.run("native:linesubstring", 
                                {'INPUT':vl,
                                 'START_DISTANCE':startDistance,
                                 'END_DISTANCE':endDistance,
                                 'OUTPUT':'memory:'})                               
        
        # Add features to the sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT_LAYER, context,
                                               vl.fields(), QgsWkbTypes.LineString, vl.crs())

        features = shortLines['OUTPUT'].getFeatures()

        for feature in features:
            sink.addFeature(feature, QgsFeatureSink.FastInsert)   
        
        self.dest_id  = dest_id




        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT_LAYER: dest_id}

    def postProcessAlgorithm(self, context, feedback):
        # Styling the arrows
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path = os.path.dirname(__file__) + '/styles/saphir_arrows.qml'
        output.loadNamedStyle(path)
        
        layerProperties = output.renderer().symbol().symbolLayers()[0].dataDefinedProperties()
        expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)'.format(self.maxValue, self.maxWidth)
        # PropertyArrowWidth -> 44
        layerProperties.property(44).setExpressionString(expressionString)
        # PropertyArrowStartWidth -> 45
        layerProperties.property(45).setExpressionString(expressionString)
        
        expressionString = 'coalesce(scale_linear(abs( "FLUX" ), 0, {0}, 0,{1}), 0)*0.8'.format(self.maxValue, self.maxWidth)
        # PropertyArrowHeadLength -> 46
        layerProperties.property(46).setExpressionString(expressionString)
        # PropertyArrowHeadThickness -> 47
        layerProperties.property(47).setExpressionString(expressionString)
        
        expressionString = '0)'
        # PropertyOffset -> 7
        layerProperties.property(7).setExpressionString(expressionString)        
        
        
        output.triggerRepaint()
        
        return {self.OUTPUT_LAYER: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'customsaphirarrows'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Flèches saphir avec échelle personnalisée')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr('Flux et déplacements')

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'flows'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CreateCustomSaphirArrowsAlgorithm()

    def icon(self):
        return QIcon(os.path.dirname(__file__) + '/images/saphir.png')